<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>grilops.sightlines API documentation</title>
<meta name="description" content="This module supports puzzles that must check sightlines through grids â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grilops.sightlines</code></h1>
</header>
<section id="section-intro">
<p>This module supports puzzles that must check sightlines through grids.</p>
<p>A sightline is a straight line through a symbol grid. It may have a stopping
condition, determined based on the symbol encountered in the grid, which, when
satisfied, results in no further symbols along the line being counted. It may
also have a custom counting or accumulation function.</p>
<p>A sightline always stops when it reaches a point not in the grid. So, if the
grid is not convex, a sightline might stop at a hole in the middle of the
grid. If it is desired that a sightline continues through such holes, the
holes should be treated as part of the grid, e.g., as black cells.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module supports puzzles that must check sightlines through grids.

A sightline is a straight line through a symbol grid. It may have a stopping
condition, determined based on the symbol encountered in the grid, which, when
satisfied, results in no further symbols along the line being counted. It may
also have a custom counting or accumulation function.

A sightline always stops when it reaches a point not in the grid. So, if the
grid is not convex, a sightline might stop at a hole in the middle of the
grid. If it is desired that a sightline continues through such holes, the
holes should be treated as part of the grid, e.g., as black cells.
&#34;&#34;&#34;

from inspect import signature
from typing import cast, Callable, TypeVar, Union
from z3 import ArithRef, BoolRef, BoolVal, ExprRef, If, IntVal

from .geometry import Point, Direction
from .grids import SymbolGrid


def count_cells(
    symbol_grid: SymbolGrid,
    start: Point,
    direction: Direction,
    count: Callable[[ArithRef], ArithRef] = lambda c: IntVal(1),
    stop: Callable[[ArithRef], BoolRef] = lambda c: BoolVal(False)
) -&gt; ArithRef:
  &#34;&#34;&#34;Returns a count of cells along a sightline through a grid.

  Args:
    symbol_grid (grilops.grids.SymbolGrid): The grid to check against.
    start (grilops.geometry.Point): The location of the cell where the
      sightline should begin. This is the first cell checked.
    direction (grilops.geometry.Direction): The direction to advance to reach
      the next cell in the sightline.
    count (Callable[[ArithRef], ArithRef]): A function that accepts
      a symbol as an argument and returns the integer value to add to the count
      when this symbol is encountered. By default, each symbol will count with
      a value of one.
    stop (Callable[[ArithRef], BoolRef]): A function that accepts a
      symbol as an argument and returns True if we should stop following the
      sightline when this symbol is encountered. By default, the sightline will
      continue to the edge of the grid.

  Returns:
    An `ArithRef` for the count of cells along the sightline through the grid.
  &#34;&#34;&#34;
  return reduce_cells(
      symbol_grid,
      start,
      direction,
      cast(ArithRef, IntVal(0)),
      lambda a, c: a + count(c),
      lambda a, c: stop(c)
  )


Accumulator = TypeVar(&#34;Accumulator&#34;, bound=ExprRef)

AccumulateCallback = Union[
    Callable[[Accumulator, ArithRef], Accumulator],
    Callable[[Accumulator, ArithRef, Point], Accumulator]
]

StopCallback = Union[
    Callable[[Accumulator, ArithRef], BoolRef],
    Callable[[Accumulator, ArithRef, Point], BoolRef]
]

def reduce_cells(  # pylint: disable=R0913
    symbol_grid: SymbolGrid,
    start: Point,
    direction: Direction,
    initializer: Accumulator,
    accumulate: AccumulateCallback,
    stop: StopCallback = lambda a, c: BoolVal(False)
) -&gt; Accumulator:
  &#34;&#34;&#34;Returns a computation of a sightline through a grid.

  Args:
    symbol_grid (grilops.grids.SymbolGrid): The grid to check against.
    start (grilops.geometry.Point): The location of the cell where the
      sightline should begin. This is the first cell checked.
    direction (grilops.geometry.Direction): The direction to advance to reach
      the next cell in the sightline.
    initializer (Accumulator): The initial value for the accumulator.
    accumulate (AccumulateCallback): A function that accepts an accumulated
      value, a symbol, and (optionally) a point as arguments, and returns a new
      accumulated value. This function is used to determine a new accumulated
      value for each cell along the sightline, based on the accumulated value
      from the previously encountered cells as well as the point and/or symbol
      of the current cell.
    stop (StopCallback): A function that accepts an accumulated value, a
      symbol, and (optionally) a point as arguments, and returns True if we
      should stop following the sightline when this symbol or point is
      encountered. By default, the sightline will continue to the edge of the
      grid.

  Returns:
    The accumulated value.

  Raises:
    ValueError: If the accumulate or stop callback doesn&#39;t accept the correct
      number of arguments.
  &#34;&#34;&#34;
  num_accumulate_args = len(signature(accumulate).parameters)
  num_stop_args = len(signature(stop).parameters)
  stop_terms = []
  acc_terms = [initializer]
  p = start
  while p in symbol_grid.grid:
    cell = symbol_grid.grid[p]
    if num_accumulate_args == 3:
      acc_term = accumulate(acc_terms[-1], cell, p)  # type: ignore[call-arg]
    elif num_accumulate_args == 2:
      acc_term = accumulate(acc_terms[-1], cell)  # type: ignore[call-arg]
    else:
      raise ValueError(&#34;wrong number of accumulate callback args&#34;)
    acc_terms.append(acc_term)
    if num_stop_args == 3:
      stop_terms.append(stop(acc_term, cell, p))  # type: ignore[call-arg]
    elif num_stop_args == 2:
      stop_terms.append(stop(acc_term, cell))  # type: ignore[call-arg]
    else:
      raise ValueError(&#34;wrong number of stop callback args&#34;)
    p = p.translate(direction.vector)
  expr = acc_terms.pop()
  for stop_term, acc_term in zip(reversed(stop_terms), reversed(acc_terms)):
    expr = If(stop_term, acc_term, expr)
  return expr</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="grilops.sightlines.count_cells"><code class="name flex">
<span>def <span class="ident">count_cells</span></span>(<span>symbol_grid:Â <a title="grilops.grids.SymbolGrid" href="grids.html#grilops.grids.SymbolGrid">SymbolGrid</a>, start:Â <a title="grilops.geometry.Point" href="geometry.html#grilops.geometry.Point">Point</a>, direction:Â <a title="grilops.geometry.Direction" href="geometry.html#grilops.geometry.Direction">Direction</a>, count:Â Callable[[z3.z3.ArithRef],Â z3.z3.ArithRef]Â =Â &lt;function &lt;lambda&gt;&gt;, stop:Â Callable[[z3.z3.ArithRef],Â z3.z3.BoolRef]Â =Â &lt;function &lt;lambda&gt;&gt;) â€‘>Â z3.z3.ArithRef</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a count of cells along a sightline through a grid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>symbol_grid</code></strong> :&ensp;<code><a title="grilops.grids.SymbolGrid" href="grids.html#grilops.grids.SymbolGrid">SymbolGrid</a></code></dt>
<dd>The grid to check against.</dd>
<dt><strong><code>start</code></strong> :&ensp;<code><a title="grilops.geometry.Point" href="geometry.html#grilops.geometry.Point">Point</a></code></dt>
<dd>The location of the cell where the
sightline should begin. This is the first cell checked.</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code><a title="grilops.geometry.Direction" href="geometry.html#grilops.geometry.Direction">Direction</a></code></dt>
<dd>The direction to advance to reach
the next cell in the sightline.</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>Callable[[ArithRef], ArithRef]</code></dt>
<dd>A function that accepts
a symbol as an argument and returns the integer value to add to the count
when this symbol is encountered. By default, each symbol will count with
a value of one.</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>Callable[[ArithRef], BoolRef]</code></dt>
<dd>A function that accepts a
symbol as an argument and returns True if we should stop following the
sightline when this symbol is encountered. By default, the sightline will
continue to the edge of the grid.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An <code>ArithRef</code> for the count of cells along the sightline through the grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_cells(
    symbol_grid: SymbolGrid,
    start: Point,
    direction: Direction,
    count: Callable[[ArithRef], ArithRef] = lambda c: IntVal(1),
    stop: Callable[[ArithRef], BoolRef] = lambda c: BoolVal(False)
) -&gt; ArithRef:
  &#34;&#34;&#34;Returns a count of cells along a sightline through a grid.

  Args:
    symbol_grid (grilops.grids.SymbolGrid): The grid to check against.
    start (grilops.geometry.Point): The location of the cell where the
      sightline should begin. This is the first cell checked.
    direction (grilops.geometry.Direction): The direction to advance to reach
      the next cell in the sightline.
    count (Callable[[ArithRef], ArithRef]): A function that accepts
      a symbol as an argument and returns the integer value to add to the count
      when this symbol is encountered. By default, each symbol will count with
      a value of one.
    stop (Callable[[ArithRef], BoolRef]): A function that accepts a
      symbol as an argument and returns True if we should stop following the
      sightline when this symbol is encountered. By default, the sightline will
      continue to the edge of the grid.

  Returns:
    An `ArithRef` for the count of cells along the sightline through the grid.
  &#34;&#34;&#34;
  return reduce_cells(
      symbol_grid,
      start,
      direction,
      cast(ArithRef, IntVal(0)),
      lambda a, c: a + count(c),
      lambda a, c: stop(c)
  )</code></pre>
</details>
</dd>
<dt id="grilops.sightlines.reduce_cells"><code class="name flex">
<span>def <span class="ident">reduce_cells</span></span>(<span>symbol_grid:Â <a title="grilops.grids.SymbolGrid" href="grids.html#grilops.grids.SymbolGrid">SymbolGrid</a>, start:Â <a title="grilops.geometry.Point" href="geometry.html#grilops.geometry.Point">Point</a>, direction:Â <a title="grilops.geometry.Direction" href="geometry.html#grilops.geometry.Direction">Direction</a>, initializer:Â ~Accumulator, accumulate:Â Union[Callable[[~Accumulator,Â z3.z3.ArithRef],Â ~Accumulator],Â Callable[[~Accumulator,Â z3.z3.ArithRef,Â <a title="grilops.geometry.Point" href="geometry.html#grilops.geometry.Point">Point</a>],Â ~Accumulator]], stop:Â Union[Callable[[~Accumulator,Â z3.z3.ArithRef],Â z3.z3.BoolRef],Â Callable[[~Accumulator,Â z3.z3.ArithRef,Â <a title="grilops.geometry.Point" href="geometry.html#grilops.geometry.Point">Point</a>],Â z3.z3.BoolRef]]Â =Â &lt;function &lt;lambda&gt;&gt;) â€‘>Â ~Accumulator</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a computation of a sightline through a grid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>symbol_grid</code></strong> :&ensp;<code><a title="grilops.grids.SymbolGrid" href="grids.html#grilops.grids.SymbolGrid">SymbolGrid</a></code></dt>
<dd>The grid to check against.</dd>
<dt><strong><code>start</code></strong> :&ensp;<code><a title="grilops.geometry.Point" href="geometry.html#grilops.geometry.Point">Point</a></code></dt>
<dd>The location of the cell where the
sightline should begin. This is the first cell checked.</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code><a title="grilops.geometry.Direction" href="geometry.html#grilops.geometry.Direction">Direction</a></code></dt>
<dd>The direction to advance to reach
the next cell in the sightline.</dd>
<dt><strong><code>initializer</code></strong> :&ensp;<code>Accumulator</code></dt>
<dd>The initial value for the accumulator.</dd>
<dt><strong><code>accumulate</code></strong> :&ensp;<code>AccumulateCallback</code></dt>
<dd>A function that accepts an accumulated
value, a symbol, and (optionally) a point as arguments, and returns a new
accumulated value. This function is used to determine a new accumulated
value for each cell along the sightline, based on the accumulated value
from the previously encountered cells as well as the point and/or symbol
of the current cell.</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>StopCallback</code></dt>
<dd>A function that accepts an accumulated value, a
symbol, and (optionally) a point as arguments, and returns True if we
should stop following the sightline when this symbol or point is
encountered. By default, the sightline will continue to the edge of the
grid.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The accumulated value.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the accumulate or stop callback doesn't accept the correct
number of arguments.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_cells(  # pylint: disable=R0913
    symbol_grid: SymbolGrid,
    start: Point,
    direction: Direction,
    initializer: Accumulator,
    accumulate: AccumulateCallback,
    stop: StopCallback = lambda a, c: BoolVal(False)
) -&gt; Accumulator:
  &#34;&#34;&#34;Returns a computation of a sightline through a grid.

  Args:
    symbol_grid (grilops.grids.SymbolGrid): The grid to check against.
    start (grilops.geometry.Point): The location of the cell where the
      sightline should begin. This is the first cell checked.
    direction (grilops.geometry.Direction): The direction to advance to reach
      the next cell in the sightline.
    initializer (Accumulator): The initial value for the accumulator.
    accumulate (AccumulateCallback): A function that accepts an accumulated
      value, a symbol, and (optionally) a point as arguments, and returns a new
      accumulated value. This function is used to determine a new accumulated
      value for each cell along the sightline, based on the accumulated value
      from the previously encountered cells as well as the point and/or symbol
      of the current cell.
    stop (StopCallback): A function that accepts an accumulated value, a
      symbol, and (optionally) a point as arguments, and returns True if we
      should stop following the sightline when this symbol or point is
      encountered. By default, the sightline will continue to the edge of the
      grid.

  Returns:
    The accumulated value.

  Raises:
    ValueError: If the accumulate or stop callback doesn&#39;t accept the correct
      number of arguments.
  &#34;&#34;&#34;
  num_accumulate_args = len(signature(accumulate).parameters)
  num_stop_args = len(signature(stop).parameters)
  stop_terms = []
  acc_terms = [initializer]
  p = start
  while p in symbol_grid.grid:
    cell = symbol_grid.grid[p]
    if num_accumulate_args == 3:
      acc_term = accumulate(acc_terms[-1], cell, p)  # type: ignore[call-arg]
    elif num_accumulate_args == 2:
      acc_term = accumulate(acc_terms[-1], cell)  # type: ignore[call-arg]
    else:
      raise ValueError(&#34;wrong number of accumulate callback args&#34;)
    acc_terms.append(acc_term)
    if num_stop_args == 3:
      stop_terms.append(stop(acc_term, cell, p))  # type: ignore[call-arg]
    elif num_stop_args == 2:
      stop_terms.append(stop(acc_term, cell))  # type: ignore[call-arg]
    else:
      raise ValueError(&#34;wrong number of stop callback args&#34;)
    p = p.translate(direction.vector)
  expr = acc_terms.pop()
  for stop_term, acc_term in zip(reversed(stop_terms), reversed(acc_terms)):
    expr = If(stop_term, acc_term, expr)
  return expr</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="grilops" href="index.html">grilops</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="grilops.sightlines.count_cells" href="#grilops.sightlines.count_cells">count_cells</a></code></li>
<li><code><a title="grilops.sightlines.reduce_cells" href="#grilops.sightlines.reduce_cells">reduce_cells</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>