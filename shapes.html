<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>grilops.shapes API documentation</title>
<meta name="description" content="This module supports puzzles that place fixed shape regions into the grid." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grilops.shapes</code></h1>
</header>
<section id="section-intro">
<p>This module supports puzzles that place fixed shape regions into the grid.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module supports puzzles that place fixed shape regions into the grid.&#34;&#34;&#34;

from collections import defaultdict
import sys
from typing import Callable, Dict, Generic, List, Optional, Tuple, TypeVar, Union
from z3 import ArithRef, Const, ExprRef, Int, IntSort, IntVal, Or, Solver, PbEq, eq

from .fastz3 import fast_and, fast_eq, fast_ne
from .geometry import Lattice, Point, Vector
from .quadtree import ExpressionQuadTree


# Key types for use with the ExpressionQuadTree when adding shape instance
# constraints.
HAS_INSTANCE_ID, NOT_HAS_INSTANCE_ID, HAS_SHAPE_TYPE = range(3)


Payload = TypeVar(&#34;Payload&#34;, bound=ExprRef)


Offset = Union[Vector, Tuple[Vector, Optional[Payload]]]


class Shape(Generic[Payload]):
  &#34;&#34;&#34;A shape defined by a list of `grilops.geometry.Vector` offsets.

  Each offset may optionally have an associated payload value.

  Args:
    offsets (List[Offset]): A list of offsets that define the shape. An offset
      may be a `grilops.geometry.Vector`; or, to optionally associate a payload
      value with the offset, it may be a
      `Tuple[grilops.geometry.Vector, Payload]`. A payload may be any z3
      expression.
  &#34;&#34;&#34;
  def __init__(self, offsets: List[Offset]):
    self.__offset_tuples: List[Tuple[Vector, Optional[Payload]]] = []
    for offset in offsets:
      if isinstance(offset, Vector):
        self.__offset_tuples.append((offset, None))
      elif isinstance(offset, tuple) and len(offset) == 2:
        self.__offset_tuples.append(offset)
      else:
        raise RuntimeError(f&#34;Invalid shape offset: {offset}&#34;)

  @property
  def offset_vectors(self) -&gt; List[Vector]:
    &#34;&#34;&#34;The offset vectors that define this shape.&#34;&#34;&#34;
    return [t[0] for t in self.__offset_tuples]

  @property
  def offsets_with_payloads(self) -&gt; List[Tuple[Vector, Optional[Payload]]]:
    &#34;&#34;&#34;The offset vector and payload value tuples for this shape.&#34;&#34;&#34;
    return self.__offset_tuples

  def transform(self, f: Callable[[Vector], Vector]) -&gt; &#34;Shape&#34;:
    &#34;&#34;&#34;Returns a new shape with each offset transformed by `f`.&#34;&#34;&#34;
    return Shape([(f(v), p) for v, p in self.__offset_tuples])

  def canonicalize(self) -&gt; &#34;Shape&#34;:
    &#34;&#34;&#34;Returns a new shape that&#39;s canonicalized.

    A canonicalized shape is in sorted order and its first offset is
    `grilops.geometry.Vector`(0, 0). This helps with deduplication, since
    equivalent shapes will be canonicalized identically.

    Returns:
      A `Shape` of offsets defining the canonicalized version of the shape,
        i.e., in sorted order and with first offset equal to
        `grilops.geometry.Vector`(0, 0).
    &#34;&#34;&#34;
    offset_tuples = sorted(self.__offset_tuples, key=lambda t: t[0])
    first_negated = offset_tuples[0][0].negate()
    return Shape([(v.translate(first_negated), p) for v, p in offset_tuples])

  def equivalent(self, shape: &#34;Shape&#34;) -&gt; bool:
    &#34;&#34;&#34;Returns true iff the given shape is equivalent to this shape.&#34;&#34;&#34;
    if len(self.offsets_with_payloads) != len(shape.offsets_with_payloads):
      return False
    for (v1, p1), (v2, p2) in zip(
        self.offsets_with_payloads,  # type: ignore[arg-type]
        shape.offsets_with_payloads  # type: ignore[arg-type]
    ):
      if v1 != v2:
        return False
      if isinstance(p1, ExprRef) and isinstance(p2, ExprRef):
        if not eq(p1, p2):
          return False
      elif p1 != p2:
        return False
    return True


class ShapeConstrainer:
  &#34;&#34;&#34;Creates constraints for placing fixed shape regions into the grid.

  Args:
    lattice (grilops.geometry.Lattice): The structure of the grid.
    shapes (List[Shape]): A list of region shape definitions. The same
      region shape definition may be included multiple times to indicate the
      number of times that shape may appear (if allow_copies is false).
    solver (Optional[z3.Solver]): A `Solver` object. If None, a `Solver` will
      be constructed.
    complete (bool): If true, every cell must be part of a shape region.
      Defaults to false.
    allow_rotations (bool): If true, allow rotations of the shapes to be placed
      in the grid. Defaults to false.
    allow_reflections (bool): If true, allow reflections of the shapes to be
      placed in the grid. Defaults to false.
    allow_copies (bool): If true, allow any number of copies of the shapes to
      be placed in the grid. Defaults to false.

  &#34;&#34;&#34;
  _instance_index = 0

  def __init__(  # pylint: disable=R0913
      self,
      lattice: Lattice,
      shapes: List[Shape],
      solver: Optional[Solver] = None,
      complete: bool = False,
      allow_rotations: bool = False,
      allow_reflections: bool = False,
      allow_copies: bool = False
  ):
    ShapeConstrainer._instance_index += 1
    if solver:
      self.__solver = solver
    else:
      self.__solver = Solver()

    self.__lattice = lattice
    self.__complete = complete
    self.__allow_copies = allow_copies

    self.__shapes = shapes
    self.__make_variants(allow_rotations, allow_reflections)

    self.__create_grids()
    self.__add_constraints()

  def __make_variants(self, allow_rotations, allow_reflections):
    fs = self.__lattice.transformation_functions(
        allow_rotations, allow_reflections)
    self.__variants = []
    for shape in self.__shapes:
      shape_variants = []
      for f in fs:
        variant = shape.transform(f).canonicalize()
        if not any(variant.equivalent(v) for v in shape_variants):
          shape_variants.append(variant)
      self.__variants.append(shape_variants)

  def __create_grids(self):
    &#34;&#34;&#34;Create the grids used to model shape region constraints.&#34;&#34;&#34;
    self.__shape_type_grid: Dict[Point, ArithRef] = {}
    for p in self.__lattice.points:
      v = Int(f&#34;scst-{ShapeConstrainer._instance_index}-{p.y}-{p.x}&#34;)
      if self.__complete:
        self.__solver.add(v &gt;= 0)
      else:
        self.__solver.add(v &gt;= -1)
      self.__solver.add(v &lt; len(self.__shapes))
      self.__shape_type_grid[p] = v

    self.__shape_instance_grid: Dict[Point, ArithRef] = {}
    for p in self.__lattice.points:
      v = Int(f&#34;scsi-{ShapeConstrainer._instance_index}-{p.y}-{p.x}&#34;)
      if self.__complete:
        self.__solver.add(v &gt;= 0)
      else:
        self.__solver.add(v &gt;= -1)
      self.__solver.add(v &lt; len(self.__lattice.points))
      self.__shape_instance_grid[p] = v

    sample_payload = self.__shapes[0].offsets_with_payloads[0][1]
    if sample_payload is None:
      self.__shape_payload_grid: Optional[Dict[Point, Payload]] = None
    else:
      self.__shape_payload_grid: Optional[Dict[Point, Payload]] = {}
      if isinstance(sample_payload, ExprRef):
        sort = sample_payload.sort()
      elif isinstance(sample_payload, int):
        sort = IntSort()
      else:
        raise RuntimeError(f&#34;Could not determine z3 sort for {sample_payload}&#34;)
      for p in self.__lattice.points:
        v = Const(f&#34;scsp-{ShapeConstrainer._instance_index}-{p.y}-{p.x}&#34;, sort)
        self.__shape_payload_grid[p] = v

  def __add_constraints(self):
    self.__add_grid_agreement_constraints()
    self.__add_shape_instance_constraints()
    if not self.__allow_copies:
      for shape_index, shape in enumerate(self.__shapes):
        self.__add_single_copy_constraints(shape_index, shape)

  def __add_grid_agreement_constraints(self):
    for p, shape_type in self.__shape_type_grid.items():
      self.__solver.add(
          Or(
              fast_and(
                  shape_type == -1,
                  self.__shape_instance_grid[p] == -1
              ),
              fast_and(
                  shape_type != -1,
                  self.__shape_instance_grid[p] != -1
              )
          )
      )

  def __add_shape_instance_constraints(self):  # pylint: disable=R0914
    int_vals = {}
    for i in range(max(len(self.__lattice.points), len(self.__variants))):
      int_vals[i] = IntVal(i)

    quadtree = ExpressionQuadTree(self.__lattice.points)
    for instance_id in [self.__lattice.point_to_index(p) for p in self.__lattice.points]:
      quadtree.add_expr(
          (HAS_INSTANCE_ID, instance_id),
          lambda p, i=instance_id: fast_eq(self.__shape_instance_grid[p], int_vals[i]))
      quadtree.add_expr(
          (NOT_HAS_INSTANCE_ID, instance_id),
          lambda p, i=instance_id: fast_ne(self.__shape_instance_grid[p], int_vals[i]))
    for shape_index in range(len(self.__variants)):
      quadtree.add_expr(
          (HAS_SHAPE_TYPE, shape_index),
          lambda p, i=shape_index: fast_eq(self.__shape_type_grid[p], int_vals[i]))

    root_options = defaultdict(list)
    for shape_index, variants in enumerate(self.__variants):  # pylint: disable=R1702
      for variant in variants:
        for root_point in self.__lattice.points:
          instance_id = self.__lattice.point_to_index(root_point)
          point_payload_tuples = []
          for offset_vector, payload in variant.offsets_with_payloads:
            point = root_point.translate(offset_vector)
            if point not in self.__shape_instance_grid:
              point_payload_tuples = None
              break
            point_payload_tuples.append((point, payload))
          if point_payload_tuples:
            and_terms = []
            for point, payload in point_payload_tuples:
              and_terms.append(
                  quadtree.get_point_expr(
                      (HAS_INSTANCE_ID, instance_id),
                      point
                  )
              )
              and_terms.append(
                  quadtree.get_point_expr(
                      (HAS_SHAPE_TYPE, shape_index),
                      point
                  )
              )
              if self.__shape_payload_grid:
                and_terms.append(self.__shape_payload_grid[point] == payload)
            and_terms.append(
                quadtree.get_other_points_expr(
                    (NOT_HAS_INSTANCE_ID, instance_id),
                    [t[0] for t in point_payload_tuples]
                )
            )
            root_options[root_point].append(fast_and(*and_terms))
    for p in self.__lattice.points:
      instance_id = self.__lattice.point_to_index(p)
      not_has_instance_id_expr = quadtree.get_other_points_expr(
          (NOT_HAS_INSTANCE_ID, instance_id), [])
      or_terms = root_options[p]
      if or_terms:
        or_terms.append(not_has_instance_id_expr)
        self.__solver.add(Or(*or_terms))
      else:
        self.__solver.add(not_has_instance_id_expr)

  def __add_single_copy_constraints(self, shape_index, shape):
    sum_terms = []
    for shape_type in self.__shape_type_grid.values():
      sum_terms.append((shape_type == shape_index, 1))
    self.__solver.add(PbEq(sum_terms, len(shape.offsets_with_payloads)))

  @property
  def solver(self) -&gt; Solver:
    &#34;&#34;&#34;The `Solver` associated with this `ShapeConstrainer`.&#34;&#34;&#34;
    return self.__solver

  @property
  def shape_type_grid(self) -&gt; Dict[Point, ArithRef]:
    &#34;&#34;&#34;A dictionary of z3 constants of shape types.

    Each cell contains the index of the shape type placed in that cell (as
    indexed by the shapes list passed in to the `ShapeConstrainer`
    constructor), or -1 if no shape is placed within that cell.
    &#34;&#34;&#34;
    return self.__shape_type_grid

  @property
  def shape_instance_grid(self) -&gt; Dict[Point, ArithRef]:
    &#34;&#34;&#34;z3 constants of shape instance IDs.

    Each cell contains a number shared among all cells containing the same
    instance of the shape, or -1 if no shape is placed within that cell.
    &#34;&#34;&#34;
    return self.__shape_instance_grid

  @property
  def shape_payload_grid(self) -&gt; Optional[Dict[Point, Payload]]:
    &#34;&#34;&#34;z3 constants of the shape offset payloads initially provided.

    None if no payloads were provided during construction.
    &#34;&#34;&#34;
    return self.__shape_payload_grid

  def print_shape_types(self):
    &#34;&#34;&#34;Prints the shape type assigned to each cell.

    Should be called only after the solver has been checked.
    &#34;&#34;&#34;
    model = self.__solver.model()
    min_y = min(p.y for p in self.__shape_type_grid)
    min_x = min(p.x for p in self.__shape_type_grid)
    max_y = max(p.y for p in self.__shape_type_grid)
    max_x = max(p.x for p in self.__shape_type_grid)
    for y in range(min_y, max_y + 1):
      for x in range(min_x, max_x + 1):
        p = Point(y, x)
        shape_index = -1
        if p in self.__shape_type_grid:
          v = self.__shape_type_grid[p]
          shape_index = model.eval(v).as_long()
        if shape_index &gt;= 0:
          sys.stdout.write(f&#34;{shape_index:3}&#34;)
        else:
          sys.stdout.write(&#34;   &#34;)
      print()

  def print_shape_instances(self):
    &#34;&#34;&#34;Prints the shape instance ID assigned to each cell.

    Should be called only after the solver has been checked.
    &#34;&#34;&#34;
    model = self.__solver.model()
    min_y = min(p.y for p in self.__shape_instance_grid)
    min_x = min(p.x for p in self.__shape_instance_grid)
    max_y = max(p.y for p in self.__shape_instance_grid)
    max_x = max(p.x for p in self.__shape_instance_grid)
    for y in range(min_y, max_y + 1):
      for x in range(min_x, max_x + 1):
        p = Point(y, x)
        shape_instance = -1
        if p in self.__shape_instance_grid:
          v = self.__shape_instance_grid[p]
          shape_instance = model.eval(v).as_long()
        if shape_instance &gt;= 0:
          sys.stdout.write(f&#34;{shape_instance:3}&#34;)
        else:
          sys.stdout.write(&#34;   &#34;)
      print()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="grilops.shapes.Shape"><code class="flex name class">
<span>class <span class="ident">Shape</span></span>
<span>(</span><span>offsets: List[Union[<a title="grilops.geometry.Vector" href="geometry.html#grilops.geometry.Vector">Vector</a>, Tuple[<a title="grilops.geometry.Vector" href="geometry.html#grilops.geometry.Vector">Vector</a>, Optional[~Payload]]]])</span>
</code></dt>
<dd>
<div class="desc"><p>A shape defined by a list of <code><a title="grilops.geometry.Vector" href="geometry.html#grilops.geometry.Vector">Vector</a></code> offsets.</p>
<p>Each offset may optionally have an associated payload value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>offsets</code></strong> :&ensp;<code>List[Offset]</code></dt>
<dd>A list of offsets that define the shape. An offset
may be a <code><a title="grilops.geometry.Vector" href="geometry.html#grilops.geometry.Vector">Vector</a></code>; or, to optionally associate a payload
value with the offset, it may be a
<code>Tuple[<a title="grilops.geometry.Vector" href="geometry.html#grilops.geometry.Vector">Vector</a>, Payload]</code>. A payload may be any z3
expression.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Shape(Generic[Payload]):
  &#34;&#34;&#34;A shape defined by a list of `grilops.geometry.Vector` offsets.

  Each offset may optionally have an associated payload value.

  Args:
    offsets (List[Offset]): A list of offsets that define the shape. An offset
      may be a `grilops.geometry.Vector`; or, to optionally associate a payload
      value with the offset, it may be a
      `Tuple[grilops.geometry.Vector, Payload]`. A payload may be any z3
      expression.
  &#34;&#34;&#34;
  def __init__(self, offsets: List[Offset]):
    self.__offset_tuples: List[Tuple[Vector, Optional[Payload]]] = []
    for offset in offsets:
      if isinstance(offset, Vector):
        self.__offset_tuples.append((offset, None))
      elif isinstance(offset, tuple) and len(offset) == 2:
        self.__offset_tuples.append(offset)
      else:
        raise RuntimeError(f&#34;Invalid shape offset: {offset}&#34;)

  @property
  def offset_vectors(self) -&gt; List[Vector]:
    &#34;&#34;&#34;The offset vectors that define this shape.&#34;&#34;&#34;
    return [t[0] for t in self.__offset_tuples]

  @property
  def offsets_with_payloads(self) -&gt; List[Tuple[Vector, Optional[Payload]]]:
    &#34;&#34;&#34;The offset vector and payload value tuples for this shape.&#34;&#34;&#34;
    return self.__offset_tuples

  def transform(self, f: Callable[[Vector], Vector]) -&gt; &#34;Shape&#34;:
    &#34;&#34;&#34;Returns a new shape with each offset transformed by `f`.&#34;&#34;&#34;
    return Shape([(f(v), p) for v, p in self.__offset_tuples])

  def canonicalize(self) -&gt; &#34;Shape&#34;:
    &#34;&#34;&#34;Returns a new shape that&#39;s canonicalized.

    A canonicalized shape is in sorted order and its first offset is
    `grilops.geometry.Vector`(0, 0). This helps with deduplication, since
    equivalent shapes will be canonicalized identically.

    Returns:
      A `Shape` of offsets defining the canonicalized version of the shape,
        i.e., in sorted order and with first offset equal to
        `grilops.geometry.Vector`(0, 0).
    &#34;&#34;&#34;
    offset_tuples = sorted(self.__offset_tuples, key=lambda t: t[0])
    first_negated = offset_tuples[0][0].negate()
    return Shape([(v.translate(first_negated), p) for v, p in offset_tuples])

  def equivalent(self, shape: &#34;Shape&#34;) -&gt; bool:
    &#34;&#34;&#34;Returns true iff the given shape is equivalent to this shape.&#34;&#34;&#34;
    if len(self.offsets_with_payloads) != len(shape.offsets_with_payloads):
      return False
    for (v1, p1), (v2, p2) in zip(
        self.offsets_with_payloads,  # type: ignore[arg-type]
        shape.offsets_with_payloads  # type: ignore[arg-type]
    ):
      if v1 != v2:
        return False
      if isinstance(p1, ExprRef) and isinstance(p2, ExprRef):
        if not eq(p1, p2):
          return False
      elif p1 != p2:
        return False
    return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="grilops.shapes.Shape.offset_vectors"><code class="name">var <span class="ident">offset_vectors</span> : List[<a title="grilops.geometry.Vector" href="geometry.html#grilops.geometry.Vector">Vector</a>]</code></dt>
<dd>
<div class="desc"><p>The offset vectors that define this shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def offset_vectors(self) -&gt; List[Vector]:
  &#34;&#34;&#34;The offset vectors that define this shape.&#34;&#34;&#34;
  return [t[0] for t in self.__offset_tuples]</code></pre>
</details>
</dd>
<dt id="grilops.shapes.Shape.offsets_with_payloads"><code class="name">var <span class="ident">offsets_with_payloads</span> : List[Tuple[<a title="grilops.geometry.Vector" href="geometry.html#grilops.geometry.Vector">Vector</a>, Optional[~Payload]]]</code></dt>
<dd>
<div class="desc"><p>The offset vector and payload value tuples for this shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def offsets_with_payloads(self) -&gt; List[Tuple[Vector, Optional[Payload]]]:
  &#34;&#34;&#34;The offset vector and payload value tuples for this shape.&#34;&#34;&#34;
  return self.__offset_tuples</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="grilops.shapes.Shape.canonicalize"><code class="name flex">
<span>def <span class="ident">canonicalize</span></span>(<span>self) ‑> <a title="grilops.shapes.Shape" href="#grilops.shapes.Shape">Shape</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new shape that's canonicalized.</p>
<p>A canonicalized shape is in sorted order and its first offset is
<code><a title="grilops.geometry.Vector" href="geometry.html#grilops.geometry.Vector">Vector</a></code>(0, 0). This helps with deduplication, since
equivalent shapes will be canonicalized identically.</p>
<h2 id="returns">Returns</h2>
<p>A <code><a title="grilops.shapes.Shape" href="#grilops.shapes.Shape">Shape</a></code> of offsets defining the canonicalized version of the shape,
i.e., in sorted order and with first offset equal to
<code><a title="grilops.geometry.Vector" href="geometry.html#grilops.geometry.Vector">Vector</a></code>(0, 0).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canonicalize(self) -&gt; &#34;Shape&#34;:
  &#34;&#34;&#34;Returns a new shape that&#39;s canonicalized.

  A canonicalized shape is in sorted order and its first offset is
  `grilops.geometry.Vector`(0, 0). This helps with deduplication, since
  equivalent shapes will be canonicalized identically.

  Returns:
    A `Shape` of offsets defining the canonicalized version of the shape,
      i.e., in sorted order and with first offset equal to
      `grilops.geometry.Vector`(0, 0).
  &#34;&#34;&#34;
  offset_tuples = sorted(self.__offset_tuples, key=lambda t: t[0])
  first_negated = offset_tuples[0][0].negate()
  return Shape([(v.translate(first_negated), p) for v, p in offset_tuples])</code></pre>
</details>
</dd>
<dt id="grilops.shapes.Shape.equivalent"><code class="name flex">
<span>def <span class="ident">equivalent</span></span>(<span>self, shape: <a title="grilops.shapes.Shape" href="#grilops.shapes.Shape">Shape</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true iff the given shape is equivalent to this shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equivalent(self, shape: &#34;Shape&#34;) -&gt; bool:
  &#34;&#34;&#34;Returns true iff the given shape is equivalent to this shape.&#34;&#34;&#34;
  if len(self.offsets_with_payloads) != len(shape.offsets_with_payloads):
    return False
  for (v1, p1), (v2, p2) in zip(
      self.offsets_with_payloads,  # type: ignore[arg-type]
      shape.offsets_with_payloads  # type: ignore[arg-type]
  ):
    if v1 != v2:
      return False
    if isinstance(p1, ExprRef) and isinstance(p2, ExprRef):
      if not eq(p1, p2):
        return False
    elif p1 != p2:
      return False
  return True</code></pre>
</details>
</dd>
<dt id="grilops.shapes.Shape.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, f: Callable[[<a title="grilops.geometry.Vector" href="geometry.html#grilops.geometry.Vector">Vector</a>], <a title="grilops.geometry.Vector" href="geometry.html#grilops.geometry.Vector">Vector</a>]) ‑> <a title="grilops.shapes.Shape" href="#grilops.shapes.Shape">Shape</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new shape with each offset transformed by <code>f</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, f: Callable[[Vector], Vector]) -&gt; &#34;Shape&#34;:
  &#34;&#34;&#34;Returns a new shape with each offset transformed by `f`.&#34;&#34;&#34;
  return Shape([(f(v), p) for v, p in self.__offset_tuples])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grilops.shapes.ShapeConstrainer"><code class="flex name class">
<span>class <span class="ident">ShapeConstrainer</span></span>
<span>(</span><span>lattice: <a title="grilops.geometry.Lattice" href="geometry.html#grilops.geometry.Lattice">Lattice</a>, shapes: List[<a title="grilops.shapes.Shape" href="#grilops.shapes.Shape">Shape</a>], solver: Optional[z3.z3.Solver] = None, complete: bool = False, allow_rotations: bool = False, allow_reflections: bool = False, allow_copies: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates constraints for placing fixed shape regions into the grid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lattice</code></strong> :&ensp;<code><a title="grilops.geometry.Lattice" href="geometry.html#grilops.geometry.Lattice">Lattice</a></code></dt>
<dd>The structure of the grid.</dd>
<dt><strong><code>shapes</code></strong> :&ensp;<code>List[<a title="grilops.shapes.Shape" href="#grilops.shapes.Shape">Shape</a>]</code></dt>
<dd>A list of region shape definitions. The same
region shape definition may be included multiple times to indicate the
number of times that shape may appear (if allow_copies is false).</dd>
<dt><strong><code>solver</code></strong> :&ensp;<code>Optional[z3.Solver]</code></dt>
<dd>A <code>Solver</code> object. If None, a <code>Solver</code> will
be constructed.</dd>
<dt><strong><code>complete</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, every cell must be part of a shape region.
Defaults to false.</dd>
<dt><strong><code>allow_rotations</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, allow rotations of the shapes to be placed
in the grid. Defaults to false.</dd>
<dt><strong><code>allow_reflections</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, allow reflections of the shapes to be
placed in the grid. Defaults to false.</dd>
<dt><strong><code>allow_copies</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, allow any number of copies of the shapes to
be placed in the grid. Defaults to false.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ShapeConstrainer:
  &#34;&#34;&#34;Creates constraints for placing fixed shape regions into the grid.

  Args:
    lattice (grilops.geometry.Lattice): The structure of the grid.
    shapes (List[Shape]): A list of region shape definitions. The same
      region shape definition may be included multiple times to indicate the
      number of times that shape may appear (if allow_copies is false).
    solver (Optional[z3.Solver]): A `Solver` object. If None, a `Solver` will
      be constructed.
    complete (bool): If true, every cell must be part of a shape region.
      Defaults to false.
    allow_rotations (bool): If true, allow rotations of the shapes to be placed
      in the grid. Defaults to false.
    allow_reflections (bool): If true, allow reflections of the shapes to be
      placed in the grid. Defaults to false.
    allow_copies (bool): If true, allow any number of copies of the shapes to
      be placed in the grid. Defaults to false.

  &#34;&#34;&#34;
  _instance_index = 0

  def __init__(  # pylint: disable=R0913
      self,
      lattice: Lattice,
      shapes: List[Shape],
      solver: Optional[Solver] = None,
      complete: bool = False,
      allow_rotations: bool = False,
      allow_reflections: bool = False,
      allow_copies: bool = False
  ):
    ShapeConstrainer._instance_index += 1
    if solver:
      self.__solver = solver
    else:
      self.__solver = Solver()

    self.__lattice = lattice
    self.__complete = complete
    self.__allow_copies = allow_copies

    self.__shapes = shapes
    self.__make_variants(allow_rotations, allow_reflections)

    self.__create_grids()
    self.__add_constraints()

  def __make_variants(self, allow_rotations, allow_reflections):
    fs = self.__lattice.transformation_functions(
        allow_rotations, allow_reflections)
    self.__variants = []
    for shape in self.__shapes:
      shape_variants = []
      for f in fs:
        variant = shape.transform(f).canonicalize()
        if not any(variant.equivalent(v) for v in shape_variants):
          shape_variants.append(variant)
      self.__variants.append(shape_variants)

  def __create_grids(self):
    &#34;&#34;&#34;Create the grids used to model shape region constraints.&#34;&#34;&#34;
    self.__shape_type_grid: Dict[Point, ArithRef] = {}
    for p in self.__lattice.points:
      v = Int(f&#34;scst-{ShapeConstrainer._instance_index}-{p.y}-{p.x}&#34;)
      if self.__complete:
        self.__solver.add(v &gt;= 0)
      else:
        self.__solver.add(v &gt;= -1)
      self.__solver.add(v &lt; len(self.__shapes))
      self.__shape_type_grid[p] = v

    self.__shape_instance_grid: Dict[Point, ArithRef] = {}
    for p in self.__lattice.points:
      v = Int(f&#34;scsi-{ShapeConstrainer._instance_index}-{p.y}-{p.x}&#34;)
      if self.__complete:
        self.__solver.add(v &gt;= 0)
      else:
        self.__solver.add(v &gt;= -1)
      self.__solver.add(v &lt; len(self.__lattice.points))
      self.__shape_instance_grid[p] = v

    sample_payload = self.__shapes[0].offsets_with_payloads[0][1]
    if sample_payload is None:
      self.__shape_payload_grid: Optional[Dict[Point, Payload]] = None
    else:
      self.__shape_payload_grid: Optional[Dict[Point, Payload]] = {}
      if isinstance(sample_payload, ExprRef):
        sort = sample_payload.sort()
      elif isinstance(sample_payload, int):
        sort = IntSort()
      else:
        raise RuntimeError(f&#34;Could not determine z3 sort for {sample_payload}&#34;)
      for p in self.__lattice.points:
        v = Const(f&#34;scsp-{ShapeConstrainer._instance_index}-{p.y}-{p.x}&#34;, sort)
        self.__shape_payload_grid[p] = v

  def __add_constraints(self):
    self.__add_grid_agreement_constraints()
    self.__add_shape_instance_constraints()
    if not self.__allow_copies:
      for shape_index, shape in enumerate(self.__shapes):
        self.__add_single_copy_constraints(shape_index, shape)

  def __add_grid_agreement_constraints(self):
    for p, shape_type in self.__shape_type_grid.items():
      self.__solver.add(
          Or(
              fast_and(
                  shape_type == -1,
                  self.__shape_instance_grid[p] == -1
              ),
              fast_and(
                  shape_type != -1,
                  self.__shape_instance_grid[p] != -1
              )
          )
      )

  def __add_shape_instance_constraints(self):  # pylint: disable=R0914
    int_vals = {}
    for i in range(max(len(self.__lattice.points), len(self.__variants))):
      int_vals[i] = IntVal(i)

    quadtree = ExpressionQuadTree(self.__lattice.points)
    for instance_id in [self.__lattice.point_to_index(p) for p in self.__lattice.points]:
      quadtree.add_expr(
          (HAS_INSTANCE_ID, instance_id),
          lambda p, i=instance_id: fast_eq(self.__shape_instance_grid[p], int_vals[i]))
      quadtree.add_expr(
          (NOT_HAS_INSTANCE_ID, instance_id),
          lambda p, i=instance_id: fast_ne(self.__shape_instance_grid[p], int_vals[i]))
    for shape_index in range(len(self.__variants)):
      quadtree.add_expr(
          (HAS_SHAPE_TYPE, shape_index),
          lambda p, i=shape_index: fast_eq(self.__shape_type_grid[p], int_vals[i]))

    root_options = defaultdict(list)
    for shape_index, variants in enumerate(self.__variants):  # pylint: disable=R1702
      for variant in variants:
        for root_point in self.__lattice.points:
          instance_id = self.__lattice.point_to_index(root_point)
          point_payload_tuples = []
          for offset_vector, payload in variant.offsets_with_payloads:
            point = root_point.translate(offset_vector)
            if point not in self.__shape_instance_grid:
              point_payload_tuples = None
              break
            point_payload_tuples.append((point, payload))
          if point_payload_tuples:
            and_terms = []
            for point, payload in point_payload_tuples:
              and_terms.append(
                  quadtree.get_point_expr(
                      (HAS_INSTANCE_ID, instance_id),
                      point
                  )
              )
              and_terms.append(
                  quadtree.get_point_expr(
                      (HAS_SHAPE_TYPE, shape_index),
                      point
                  )
              )
              if self.__shape_payload_grid:
                and_terms.append(self.__shape_payload_grid[point] == payload)
            and_terms.append(
                quadtree.get_other_points_expr(
                    (NOT_HAS_INSTANCE_ID, instance_id),
                    [t[0] for t in point_payload_tuples]
                )
            )
            root_options[root_point].append(fast_and(*and_terms))
    for p in self.__lattice.points:
      instance_id = self.__lattice.point_to_index(p)
      not_has_instance_id_expr = quadtree.get_other_points_expr(
          (NOT_HAS_INSTANCE_ID, instance_id), [])
      or_terms = root_options[p]
      if or_terms:
        or_terms.append(not_has_instance_id_expr)
        self.__solver.add(Or(*or_terms))
      else:
        self.__solver.add(not_has_instance_id_expr)

  def __add_single_copy_constraints(self, shape_index, shape):
    sum_terms = []
    for shape_type in self.__shape_type_grid.values():
      sum_terms.append((shape_type == shape_index, 1))
    self.__solver.add(PbEq(sum_terms, len(shape.offsets_with_payloads)))

  @property
  def solver(self) -&gt; Solver:
    &#34;&#34;&#34;The `Solver` associated with this `ShapeConstrainer`.&#34;&#34;&#34;
    return self.__solver

  @property
  def shape_type_grid(self) -&gt; Dict[Point, ArithRef]:
    &#34;&#34;&#34;A dictionary of z3 constants of shape types.

    Each cell contains the index of the shape type placed in that cell (as
    indexed by the shapes list passed in to the `ShapeConstrainer`
    constructor), or -1 if no shape is placed within that cell.
    &#34;&#34;&#34;
    return self.__shape_type_grid

  @property
  def shape_instance_grid(self) -&gt; Dict[Point, ArithRef]:
    &#34;&#34;&#34;z3 constants of shape instance IDs.

    Each cell contains a number shared among all cells containing the same
    instance of the shape, or -1 if no shape is placed within that cell.
    &#34;&#34;&#34;
    return self.__shape_instance_grid

  @property
  def shape_payload_grid(self) -&gt; Optional[Dict[Point, Payload]]:
    &#34;&#34;&#34;z3 constants of the shape offset payloads initially provided.

    None if no payloads were provided during construction.
    &#34;&#34;&#34;
    return self.__shape_payload_grid

  def print_shape_types(self):
    &#34;&#34;&#34;Prints the shape type assigned to each cell.

    Should be called only after the solver has been checked.
    &#34;&#34;&#34;
    model = self.__solver.model()
    min_y = min(p.y for p in self.__shape_type_grid)
    min_x = min(p.x for p in self.__shape_type_grid)
    max_y = max(p.y for p in self.__shape_type_grid)
    max_x = max(p.x for p in self.__shape_type_grid)
    for y in range(min_y, max_y + 1):
      for x in range(min_x, max_x + 1):
        p = Point(y, x)
        shape_index = -1
        if p in self.__shape_type_grid:
          v = self.__shape_type_grid[p]
          shape_index = model.eval(v).as_long()
        if shape_index &gt;= 0:
          sys.stdout.write(f&#34;{shape_index:3}&#34;)
        else:
          sys.stdout.write(&#34;   &#34;)
      print()

  def print_shape_instances(self):
    &#34;&#34;&#34;Prints the shape instance ID assigned to each cell.

    Should be called only after the solver has been checked.
    &#34;&#34;&#34;
    model = self.__solver.model()
    min_y = min(p.y for p in self.__shape_instance_grid)
    min_x = min(p.x for p in self.__shape_instance_grid)
    max_y = max(p.y for p in self.__shape_instance_grid)
    max_x = max(p.x for p in self.__shape_instance_grid)
    for y in range(min_y, max_y + 1):
      for x in range(min_x, max_x + 1):
        p = Point(y, x)
        shape_instance = -1
        if p in self.__shape_instance_grid:
          v = self.__shape_instance_grid[p]
          shape_instance = model.eval(v).as_long()
        if shape_instance &gt;= 0:
          sys.stdout.write(f&#34;{shape_instance:3}&#34;)
        else:
          sys.stdout.write(&#34;   &#34;)
      print()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="grilops.shapes.ShapeConstrainer.shape_instance_grid"><code class="name">var <span class="ident">shape_instance_grid</span> : Dict[<a title="grilops.geometry.Point" href="geometry.html#grilops.geometry.Point">Point</a>, z3.z3.ArithRef]</code></dt>
<dd>
<div class="desc"><p>z3 constants of shape instance IDs.</p>
<p>Each cell contains a number shared among all cells containing the same
instance of the shape, or -1 if no shape is placed within that cell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape_instance_grid(self) -&gt; Dict[Point, ArithRef]:
  &#34;&#34;&#34;z3 constants of shape instance IDs.

  Each cell contains a number shared among all cells containing the same
  instance of the shape, or -1 if no shape is placed within that cell.
  &#34;&#34;&#34;
  return self.__shape_instance_grid</code></pre>
</details>
</dd>
<dt id="grilops.shapes.ShapeConstrainer.shape_payload_grid"><code class="name">var <span class="ident">shape_payload_grid</span> : Optional[Dict[<a title="grilops.geometry.Point" href="geometry.html#grilops.geometry.Point">Point</a>, ~Payload]]</code></dt>
<dd>
<div class="desc"><p>z3 constants of the shape offset payloads initially provided.</p>
<p>None if no payloads were provided during construction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape_payload_grid(self) -&gt; Optional[Dict[Point, Payload]]:
  &#34;&#34;&#34;z3 constants of the shape offset payloads initially provided.

  None if no payloads were provided during construction.
  &#34;&#34;&#34;
  return self.__shape_payload_grid</code></pre>
</details>
</dd>
<dt id="grilops.shapes.ShapeConstrainer.shape_type_grid"><code class="name">var <span class="ident">shape_type_grid</span> : Dict[<a title="grilops.geometry.Point" href="geometry.html#grilops.geometry.Point">Point</a>, z3.z3.ArithRef]</code></dt>
<dd>
<div class="desc"><p>A dictionary of z3 constants of shape types.</p>
<p>Each cell contains the index of the shape type placed in that cell (as
indexed by the shapes list passed in to the <code><a title="grilops.shapes.ShapeConstrainer" href="#grilops.shapes.ShapeConstrainer">ShapeConstrainer</a></code>
constructor), or -1 if no shape is placed within that cell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape_type_grid(self) -&gt; Dict[Point, ArithRef]:
  &#34;&#34;&#34;A dictionary of z3 constants of shape types.

  Each cell contains the index of the shape type placed in that cell (as
  indexed by the shapes list passed in to the `ShapeConstrainer`
  constructor), or -1 if no shape is placed within that cell.
  &#34;&#34;&#34;
  return self.__shape_type_grid</code></pre>
</details>
</dd>
<dt id="grilops.shapes.ShapeConstrainer.solver"><code class="name">var <span class="ident">solver</span> : z3.z3.Solver</code></dt>
<dd>
<div class="desc"><p>The <code>Solver</code> associated with this <code><a title="grilops.shapes.ShapeConstrainer" href="#grilops.shapes.ShapeConstrainer">ShapeConstrainer</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def solver(self) -&gt; Solver:
  &#34;&#34;&#34;The `Solver` associated with this `ShapeConstrainer`.&#34;&#34;&#34;
  return self.__solver</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="grilops.shapes.ShapeConstrainer.print_shape_instances"><code class="name flex">
<span>def <span class="ident">print_shape_instances</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the shape instance ID assigned to each cell.</p>
<p>Should be called only after the solver has been checked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_shape_instances(self):
  &#34;&#34;&#34;Prints the shape instance ID assigned to each cell.

  Should be called only after the solver has been checked.
  &#34;&#34;&#34;
  model = self.__solver.model()
  min_y = min(p.y for p in self.__shape_instance_grid)
  min_x = min(p.x for p in self.__shape_instance_grid)
  max_y = max(p.y for p in self.__shape_instance_grid)
  max_x = max(p.x for p in self.__shape_instance_grid)
  for y in range(min_y, max_y + 1):
    for x in range(min_x, max_x + 1):
      p = Point(y, x)
      shape_instance = -1
      if p in self.__shape_instance_grid:
        v = self.__shape_instance_grid[p]
        shape_instance = model.eval(v).as_long()
      if shape_instance &gt;= 0:
        sys.stdout.write(f&#34;{shape_instance:3}&#34;)
      else:
        sys.stdout.write(&#34;   &#34;)
    print()</code></pre>
</details>
</dd>
<dt id="grilops.shapes.ShapeConstrainer.print_shape_types"><code class="name flex">
<span>def <span class="ident">print_shape_types</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the shape type assigned to each cell.</p>
<p>Should be called only after the solver has been checked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_shape_types(self):
  &#34;&#34;&#34;Prints the shape type assigned to each cell.

  Should be called only after the solver has been checked.
  &#34;&#34;&#34;
  model = self.__solver.model()
  min_y = min(p.y for p in self.__shape_type_grid)
  min_x = min(p.x for p in self.__shape_type_grid)
  max_y = max(p.y for p in self.__shape_type_grid)
  max_x = max(p.x for p in self.__shape_type_grid)
  for y in range(min_y, max_y + 1):
    for x in range(min_x, max_x + 1):
      p = Point(y, x)
      shape_index = -1
      if p in self.__shape_type_grid:
        v = self.__shape_type_grid[p]
        shape_index = model.eval(v).as_long()
      if shape_index &gt;= 0:
        sys.stdout.write(f&#34;{shape_index:3}&#34;)
      else:
        sys.stdout.write(&#34;   &#34;)
    print()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="grilops" href="index.html">grilops</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="grilops.shapes.Shape" href="#grilops.shapes.Shape">Shape</a></code></h4>
<ul class="">
<li><code><a title="grilops.shapes.Shape.canonicalize" href="#grilops.shapes.Shape.canonicalize">canonicalize</a></code></li>
<li><code><a title="grilops.shapes.Shape.equivalent" href="#grilops.shapes.Shape.equivalent">equivalent</a></code></li>
<li><code><a title="grilops.shapes.Shape.offset_vectors" href="#grilops.shapes.Shape.offset_vectors">offset_vectors</a></code></li>
<li><code><a title="grilops.shapes.Shape.offsets_with_payloads" href="#grilops.shapes.Shape.offsets_with_payloads">offsets_with_payloads</a></code></li>
<li><code><a title="grilops.shapes.Shape.transform" href="#grilops.shapes.Shape.transform">transform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grilops.shapes.ShapeConstrainer" href="#grilops.shapes.ShapeConstrainer">ShapeConstrainer</a></code></h4>
<ul class="">
<li><code><a title="grilops.shapes.ShapeConstrainer.print_shape_instances" href="#grilops.shapes.ShapeConstrainer.print_shape_instances">print_shape_instances</a></code></li>
<li><code><a title="grilops.shapes.ShapeConstrainer.print_shape_types" href="#grilops.shapes.ShapeConstrainer.print_shape_types">print_shape_types</a></code></li>
<li><code><a title="grilops.shapes.ShapeConstrainer.shape_instance_grid" href="#grilops.shapes.ShapeConstrainer.shape_instance_grid">shape_instance_grid</a></code></li>
<li><code><a title="grilops.shapes.ShapeConstrainer.shape_payload_grid" href="#grilops.shapes.ShapeConstrainer.shape_payload_grid">shape_payload_grid</a></code></li>
<li><code><a title="grilops.shapes.ShapeConstrainer.shape_type_grid" href="#grilops.shapes.ShapeConstrainer.shape_type_grid">shape_type_grid</a></code></li>
<li><code><a title="grilops.shapes.ShapeConstrainer.solver" href="#grilops.shapes.ShapeConstrainer.solver">solver</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>